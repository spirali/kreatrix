import: "xml".

localImport: "utils.kx".
localImport: "type.kx".
localImport: "function.kx".
localImport: "wrapper.kx".
localImport: "class.kx".
localImport: "struct.kx".
localImport: "enum.kx".

"Initalizing and reading configs ... " println.

Constant = Object clone do: {
	type = "Constant".
	name <- "".
	value <- "".
	valueType <- "".

	valueCode = {
		^#("KX" (valueType asUppercase) "(" value ")") asString.
	}.

	getCode = { 
		^"\tkxobject_set_slot_no_ref2(self, KXSYMBOL(\"",name,"\"),",valueCode,");\n".
	}.
}.

IntegerConstant = Constant clone do: {
	type = "IntegerConstant".
	
	valueType = "integer".
}.

Generator = Object clone do: {
	type = "Generator".
	
	constants = #().

	addType: = { :aType |
		types add: aType.
	}.

	outputPrefix = "".


	initTypes = { 
		types = #(GTypeVoid).

		types add: (GTypePrimitive clone 
			name: "integer" cname: "gint" convertName: "int").
		types add: (GTypePrimitive clone 
			name: "integer" cname: "guint" convertName: "int").
		types add: (GTypePrimitive clone 
			name: "string" cname: "gchar*" convertName: "cstring").
		types add: (GTypePrimitive clone 
			name: "gboolean" cname: "gboolean" convertName: "gboolean").
		types add: (GTypePrimitive clone 
			name: "float" cname: "gdouble" convertName: "double").
		types add: (GTypePrimitive clone 
			name: "float" cname: "gfloat" convertName: "double").
		types add: (GTypePrimitive clone 
			name: "integer" cname: "guint32" convertName: "int").


		addType: (GType clone name: "GdkEvent" cname: "GdkEvent*").
		addType: (GTypePrimitive clone name: "GdkEvent" cname: "GdkEventKey*" convertName: "GdkEvent").

	}.

	

	loadEnums = {
		|enums|
		enums << GEnum loadFromFile: "enums.txt".

		enums foreach: [ :each | 
			constants join: each getConstants.
			addType: each getType.
		].
	}.

	initTypes.

	loadEnums.


	document = xml Document clone readFile: "class.xml".

	rootClass = GClass clone.
	rootClass generator: self.

	rootClass loadFromElement: (document rootElement child: "class").

	allWrappers = rootClass allClasses.

	/*allClasses foreach: [ :class |
		class generator: nil.
		class parent: nil.
		class childrens: nil.
	].*/

	multiPartsNames <- #().


	functions = #().


	headers = {
		^allWrappers collect: [ :class | class filenameH ].
	}.
	
	
	initialize = {
		allWrappers join: (GStruct loadFromFileType1: "structs.txt" generator: self).
		types join: (allWrappers collect: [ :wrapper | wrapper getType ]).

		multiPartsNames: (findMultiPartsNameWrappers sort: [ :a :b | a size < b size ]) reversed.
	}.

	includeString = { 
		includeString = 
			(headers collect: [ :filename | "#include \"",filename,"\"\n" ]) asString.
		includeString = includeString, "#include \"gtk_utils.h\"".
		^includeString.
	}.

	loadFunctions = { |linenumber file|
		file << (File clone name: "functions.txt") openForReading.
		linenumber << 0.
		file foreachLine: [ :line | |definition|
			linenumber << linenumber + 1.
			line << line trim.
			((line beginsWith: "//") \/ (line == "")) ifFalse: [
				definition <<  GFuncDefinition clone.
				definition generator: self.
				definition fromString: line atLine: linenumber.
				//functions add: (GFunction cloneWithDefinition: definition generator: self).
				functions add: (definition createGFunctionGenerator: self).
			].
		].
		file close.
	}.

	findType: = { :typeName |
		^types detect: [ :type | type cname == typeName ] ifNone: [ 
			throw: (Exception clone message: "Unknown type '",typeName,"'").
		].
	}.

	findType:lineNumber: = { :typeName :aLineNumber | |allowNil type|
	//	types println.
		allowNil << false.
		(typeName endsWith: "_NULL*") ifTrue: [ 
			typeName << (typeName sliceTo: (typeName size - 6)),"*".
			allowNil << true.
		].
		type << types detect: [ :type | type cname == typeName ] ifNone: [ 
			throw: (Exception clone message: "functions:",aLineNumber,":Unknown type '",typeName,"'").
		].
		
		allowNil ifTrue: [ 
			^type clone allowNil: true.
		].
		^type.
	}.

	findMultiPartsNameWrappers = { |list|
		list << #().
		(allWrappers foreach: [ :wrapper |  |pref count|
			pref << wrapper functionsPrefix.
			count << 0.
			pref foreach: [ :char | char == '_' ifTrue: [ count << count + 1 ] ].
			(count > 1) ifTrue: [ list add: pref ].
				
		]).
		^list.
	}.

	findMultiPartsPrefix: = { :aString | 
		^multiPartsNames detect: [ :each | aString beginsWith: each] ifNone: [ nil ].
	}.

	
	initFunctionsForWrappers = {
		allWrappers foreach: [ :class | class initFunctions ].
	}.

	/*checkFunctions = { |list|
		list << functions select: [ :func | func slotName isNil ].
		list isEmpty ifFalse: [ 
			"Automatic name cannot be generated for functions: " println.
			list foreach: [ :func | func call println ].
			VM quit.
		].
	}.*/

	createMakefile = { |rep filenames filenames_colon|
		"Creating makefile ... " println.
		filenames << (allWrappers collect: 
				[ :class | 
					class filenameH," \\\n", class filenameC," \\\n" 
				]) asString.

		filenames_colon << (allWrappers collect: 
				[ :class | 
					class filenameH,": kxgenerated.tmp\n", 
					class filenameC,": kxgenerated.tmp\n" 
				]) asString.



		rep << Replacer clone loadTemplate: "Makefile-template.am".
		rep replaceDictionary: #(
			("%filenames%" => filenames)
			("%filenames_colon%" => filenames_colon)
		) asDictionary.
		rep saveTo: "../Makefile.am".
	}.

	constantsString = { 
		^(constants collect: [ :each | each getCode ]) asString.
	}.

	createModule = { |rep extensions prototypes removePrototypesString include|
		"Creating module ... " println.
		extensions << (allWrappers collect: 
				[ :class | 
					class initExtensionString,"\n"
				]) asString.
		prototypes << (allWrappers collect: 
				[ :class | 
					class callInitPrototypeString,"\n"
				]) asString.

		removePrototypesString << (allWrappers collect: 
				[ :class |
					"\t",class removePrototypeString,"\n" ]) asString.
		rep << Replacer clone loadTemplate: "module.c".
		rep replaceDictionary: #(
			("%init_extensions%" => extensions)
			("%remove_prototypes%" => removePrototypesString)
			("%init_prototypes%" => prototypes)
			("%constants%" => constantsString)
			("%include%" => includeString)
		) asDictionary.
		rep saveTo: "../gtk.c".
	}.
	

	create = {
		(args size > 0) ifTrue: [
			createMakefile.
		].
		createModule.
		allWrappers foreach: [ :class | class create ].
	}.

	findWrapperByFunctionPrefix: = { :aString | 
		^allWrappers detect: [ :each | 
			aString beginsWith: each functionsPrefix 
		] ifNone: [ nil ].
	}.

	findWrapperByName: = { :aString | 
		^allWrappers detect: [ :each | 
			aString == each cname 
		] ifNone: [ nil ].
	}.


}.


Generator do: {
	initialize.
	loadFunctions.
	initFunctionsForWrappers.
	//checkFunctions.
	//functions foreach: [ :each | (each call , ":", each className,":", each returnType ,"/",(each params asStringDelimiter: ",")) println. ].
	create.

	//allClasses foreach: [ :class | (class name, " ", class functions printString) println].
}.

